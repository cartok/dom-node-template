<!-- https://benchmarkjs.com/ -->
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.11/lodash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/platform@1.3.5/platform.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/benchmark@2.1.4/benchmark.min.js"></script>
<script>
    window.bench = new Benchmark.Suite()
        .on("start cycle", function(event){
            console.log("starting cycle")
        })
        .on("cycle", function(event){
            console.log(String(event.target))
        })
        .on("complete", function(){
            console.log(`Fastest is ${window.bench.filter('fastest').map('name')}`)
        })
</script>
   
<script src="https://cdn.jsdelivr.net/npm/dom-node-template@3.0.1-6/dist/bundle.js"></script>
<!-- <script type="module" src="../src/NodeTemplate.js"></script> -->
<script>
    window.NodeTemplate_3016 = NodeTemplate
</script>

<script src="https://cdn.jsdelivr.net/npm/dom-node-template@3.0.1-1/dist/bundle.js"></script>
<script>
    window.NodeTemplate_3011 = NodeTemplate
</script>


<script src="https://cdn.jsdelivr.net/npm/dom-node-template@latest/build/bundle.js"></script>
      

<script>

    const simpleText = `
        <div>
            <div>
                <div>
                    <div>
                        <div>
                            <div></div>
                        </div>
                    </div>
                </div>
            </div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    `
    const complexText = `
        <svg 
            class="bbox"
            >
            <g  
                data-ref="position-node" 
                transform="translate(0, 0)"
                >

                <g
                    data-ref="container-node" 
                    transform="translate(0, 0)"
                    >
                    
                    <rect 
                        data-ref="collision-node" 
                        x="0" 
                        y="0" 
                        width="0" 
                        height="0" 
                        stroke="none" 
                        stroke-width="0"
                        fill="gray"
                        />

                    <svg 
                        data-ref="border-node" 
                        x="0"
                        y="0"
                        width="0"
                        height="0"
                        >
                        <g 
                            data-ref="border-group" 
                            fill="black" 
                            stroke="none" 
                            stroke-width="0"
                            >
                            <polygon 
                                data-ref="border-top" 
                                points="0,0 0,0 0,0 0,0"
                                />
                            <polygon 
                                data-ref="border-right" 
                                points="0,0 0,0 0,0 0,0"
                                />
                            <polygon 
                                data-ref="border-bottom" 
                                points="0,0 0,0 0,0 0,0"
                                />
                            <polygon 
                                data-ref="border-left" 
                                points="0,0 0,0 0,0 0,0"
                                />
                        </g>
                    </svg>

                    <rect 
                        data-ref="cursor-node"
                        fill="transparent"
                        stroke="none"
                        stroke-width="0"
                        x="0"
                        y="0"
                        width="0"
                        height="0"
                        />
                </g>
            </g>
        </svg>

        <div transform="translate(1, 2)
            translate (
                3,
                4
            )
            translate(1px, 0px)
            rotate(-0deg)
            scale(0.5, 0.5)"
            
            style="
                text-shadow: 1px 1px 2px black, 0 0 25px blue; 
                color: rgba(200, 300,  2, .18 );
                text-shadow: 0 0 3px #FF0000, 0 0 5px #0000FF;
                background: url('img.gif') right bottom no-repeat, url('img.gif') left top repeat;
                background: linear-gradient(to bottom, #1e5799 0%, #2989d8 50%, #207cca  51%, #7db9e8 100%);
            ">
        </div>

        <div
            attribute="
                foo,
                bar,
                baz
            "/>
    `

    // bench
    //     .add("3.0.1-1", () => {
    //         let complex3011 = new NodeTemplate_3011(complexText)
    //     })
    //     .add("3.0.1-6", () => {
    //         let complex3016 = new NodeTemplate_3016(complexText)
    //     })
    //     .run({ "async": true, "queued": true })

    bench
        .add("clean old", () => {
            cleanInputString_old(complexText, { removeComments: false })
        })
        .add("clean new", () => {
            cleanInputString(complexText, { removeComments: false })
        })
        .run({ "async": false, "queued": true })


    function cleanInputString(text, options){
        options = Object.assign({}, options)
        let { removeComments } = options
        
        // perf: string methods (split, fast for)
        // proof: https://jsperf.com/node-template-string-cleanup-remove-comments
        if(removeComments){
            let lines = text.split("\n")
            for(let i = lines.length; i--;){
                let position = lines[i].indexOf("//")
                let found = (position !== -1)
                if(found){
                    if(position > 0){
                        // skip 'https://' and 'file:///'
                        let precedingChar = lines[i].charAt(position - 1)
                        let followingChar = lines[i].charAt(position + 2)
                        let subPosition = null
                        while(precedingChar === ":"){
                            if(followingChar === "/"){
                                // continue search in substring
                                position += 3
                                subPosition = lines[i].substring(position).indexOf("//")                
                            } else {
                                // continue search in substring
                                position += 2
                                subPosition = lines[i].substring(position).indexOf("//")                
                            }
                            found = (subPosition !== -1)
                            if(found){
                                // repeat
                                position += subPosition
                                precedingChar = lines[i].charAt(position - 1)
                                followingChar = lines[i].charAt(position + 2)   
                            } else {
                                // while-loop: nothing found => finish search
                                break
                            }
                        }
                        // for-loop: nothing found after detecting https:// or file:/// => next line
                        if(!found){
                            continue
                        }
                    }
                    // remove comment
                    lines[i] = lines[i].substring(0, position)
                }
            }
            text = lines.join("\n")
        }

        // perf: substring loop
        // proof: https://jsperf.com/node-template-string-cleanup-complex
        let index = 0
        let found = false
        do {
            let removeSpaceBeforeOffsetOne = false
            let removeSpaceAfterOffsetTwo = false
            let removeSpaceAfterOffsetThree = false
            removeSpaceBeforeOffsetOne = (index = text.indexOf("\n")) !== -1
                || (index = text.indexOf("\t")) !== -1
                || (index = text.indexOf("  ")) !== -1
                || (index = text.indexOf(" <")) !== -1
                || (index = text.indexOf(" >")) !== -1
                || (index = text.indexOf(" />")) !== -1
                || (index = text.indexOf(" '")) !== -1
                || (index = text.indexOf(" \"")) !== -1
                || (index = text.indexOf(" (")) !== -1
                || (index = text.indexOf(" )")) !== -1
                || (index = text.indexOf(" ,")) !== -1
                || (index = text.indexOf(" ;")) !== -1
            if(removeSpaceBeforeOffsetOne){
                // target-offset = 1
                text = text.substring(0, index) + text.substring(index + 1)
            }

            removeSpaceAfterOffsetTwo = (index = text.indexOf("< ")) !== -1
                || (index = text.indexOf("> ")) !== -1
                || (index = text.indexOf("( ")) !== -1
                || (index = text.indexOf("= \"")) !== -1
            if(removeSpaceAfterOffsetTwo){
                // target-offset = 2
                text = text.substring(0, index + 1) + text.substring(index + 2)
            }

            removeSpaceAfterOffsetThree = (index = text.indexOf("</ ")) !== -1
                || (index = text.indexOf("=\" ")) !== -1
                || (index = text.indexOf(")\" >")) !== -1
            if(removeSpaceAfterOffsetThree){
                // target-offset = 3
                text = text.substring(0, index + 2) + text.substring(index + 3)
            }

            found = removeSpaceBeforeOffsetOne || removeSpaceAfterOffsetTwo || removeSpaceAfterOffsetThree
        } while(found)

        return text
    }
    function cleanInputString_old(tagText, options = {}){
        let { removeComments } = options
        
        if(removeComments){
            // remove js line comments.
            tagText = tagText.replace(/\s*(?<![\:\/])\/{2}.*$/gm, "")
        }

        // remove all newlines, tabs and returns from the tagText string to create one line
        // regex: [\n\t\r]
        // subst: null
        tagText = tagText.replace(/[\n\t\r]/g, "")

        // style multiline specific:
        // ------------------------------------------------------------------
        // remove all spaces > 2 
        // regex: \s{2,}
        // subst: null
        tagText = tagText.replace(/\s{2,}/g, " ")
        
        // add space after every ; in style attributes
        // regex: ;([^\s])
        // subst: ; $1
        tagText = tagText.replace(/;([^\s])/g, "; $1")
        
        // remove space before "> close combination
        // regex: \s(">)
        // subst: $1
        tagText = tagText.replace(/\s(">)/g, "$1")    

        // ------------------------------------------------------------------

        // remove all whitespace between tags but not inside of tags
        // regex: >\s*<
        // subst: ><
        tagText = tagText.replace(/>\s*</g, "><")

        // remove all whitespace before the first tag or after the last tag
        // regex: ^(\s*)|(\s*)$
        // subst: null
        tagText = tagText.replace(/^(\s*)|(\s*)$/g, "")

        // remove spaces before tagText nodes
        // regex: >\s*
        // subst: >
        tagText = tagText.replace(/>\s*/g, ">")
        
        // remove spaces after tagText nodes
        // regex: \s*<
        // subst: <
        tagText = tagText.replace(/\s*</g, "<")

        // remove space between opening tag and first attribute
        // regex: (<\w*)(\s{2,})
        // subst: $1\s
        tagText = tagText.replace(/(<\w+)(\s{2,})/g, "$1 ")

        // remove space between attributes (trailing space)
        // regex: ([\w-_]+="[\w\s-_]+")(\s*(?!>))
        // subst: $1\s
        tagText = tagText.replace(/([\w-_]+="[\w\s-_]+")(\s*(?!>))/g, "$1 ")

        // remove space between last attribute and closing tag
        // regex: (\w+="\w+")(\s+)>
        // subst: $1>
        tagText = tagText.replace(/([\w-_]+="[\w\s-_]+")(\s{2,})>/g, "$1>")
        
        return tagText
    }

    const fragment = document.createRange().createContextualFragment(cleanInputString(complexText))
    console.log(fragment)
    console.log(getNodeReferences_old(fragment))
    console.log(getNodeReferences(fragment))
    // bench
    //     .add("add references old", () => {
    //         getNodeReferences_old(fragment)
    //     })
    //     .add("add references new", () => {
    //         getNodeReferences(fragment)
    //     })
        // .run({ "async": true, "queued": true })
    
    function getNodeReferences(fragment, options){
        const result = {
            root: (fragment.childNodes.length === 1)
                ? fragment.firstElementChild
                : Array.from(fragment.childNodes),
            refs: {},
            ids: {},
        }

        if(options){
            const { refs, ids } = options
            // perf: use for-reverse-decement-condition
            // proof:  https://jsperf.com/for-vs-foreach/75
            // proof:  https://jsperf.com/reduce-vs-loop/12
            if(refs){
                for(let i = refs.length; i--;){
                    result.refs[refs[i]] = fragment.querySelector(`[data-ref="${refs[i]}"]`)
                }
            }
            if(ids){
                for(let i = ids.length; i--;){
                    result.ids[refs[i]] = fragment.getElementById(refs[i])
                }
            }
        } else {
            // perf: use for
            // proof:  https://jsperf.com/for-vs-foreach/75
            // perf: use recursion
            // proof: https://jsperf.com/dom-traversal-recursive-vs-iterative
            const nodes = Array.from(fragment.childNodes)
            for(let i = nodes.length; i--;){
                iterate(nodes[i], node => {
                    // add data-ref references
                    let ref = undefined
                    if(node.dataset === undefined){
                        ref = node.getAttribute("data-ref")
                        if(ref !== null){
                            result.refs[ref] = node
                        }
                    } else {
                        ref = node.dataset.ref
                        if(ref !== undefined){
                            result.refs[ref] = node
                        }
                    }
                    // add node id references
                    if(node.id !== "") {
                        result.ids[node.id] = node
                    }
                })
            } 
        }

        return result
    }

    function getNodeReferences_old(fragment){
        // add element references from 'data-tref' and 'id' attributes
        const result = {
            root: (fragment.childNodes.length === 1)
                ? fragment.firstElementChild
                : Array.from(fragment.childNodes),
            refs: {},
            ids: {},
        }
        Array.from(fragment.childNodes).forEach(tagGroup => iterate(tagGroup, n => {
            // add data-ref references
            let ref = undefined
            if(n.dataset === undefined){
                ref = n.getAttribute("data-ref")
                if(ref !== null){
                    result.refs[ref] = n
                }
            } else {
                ref = n.dataset.ref
                if(ref !== undefined){
                    result.refs[ref] = n
                }
            }
            // add node id references
            if (n.id !== "") {
                result.ids[n.id] = n
            }
        }))
        return result
    }

    function iterate(node, callback){
        if(node !== null){
            if(!((node instanceof Node) && (node.nodeType === Node.ELEMENT_NODE))){
                return
            }
            // execute callback
            callback(node)
            if(node.hasChildNodes()){
                iterate(node.firstElementChild, callback)
            }
            if(node.nextElementSibling !== null){
                iterate(node.nextElementSibling, callback)
            }
        }
    }
</script>